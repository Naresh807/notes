Source   [https://www.baeldung.com/database-auditing-jpa]

@Audited
@AudtiTable(value = "tablename")

With Hibernate, we could make use of Interceptors and EventListeners as well as database triggers to accomplish auditing.
But the ORM framework offers Envers, a module implementing auditing and versioning of persistent classes.

**Get Started With Envers
To set up Envers, you need to add the hibernate-envers JAR into your classpath:

<dependency>
    <groupId>org.hibernate</groupId>
    <artifactId>hibernate-envers</artifactId>
    <version>${hibernate.version}</version>
</dependency>
Then just add the @Audited annotation either on an @Entity (to audit the whole entity) or on specific @Columns (if you need to audit
 specific properties only):

@Entity
@Audited
public class Bar { ... }
Note that Bar has a one-to-many relationship with Foo.
 In this case, we either need to audit Foo as well by adding @Audited on Foo or set @NotAudited on the relationship’s property in Bar:
________________________________________________________________________________________________________________________________
Creating Audit Log Tables
There are several ways to create audit tables:

      1.  set hibernate.hbm2ddl.auto to create, create-drop or update, so Envers can create them automatically
      2.  use org.hibernate.tool.EnversSchemaGenerator to export the complete database schema programmatically
      3.  use an Ant task to generate appropriate DDL statements
      4.  use a Maven plugin for generating a database schema from your mappings (such as Juplo) to export Envers schema 
                                                                                            (works with Hibernate 4 and higher)
We’ll go the first route, as it is the most straightforward, but be aware that using hibernate.hbm2ddl.auto is not safe in production.

In our case, bar_AUD and foo_AUD (if you've set Foo as @Audited as well) tables should be generated automatically. 
The audit tables copy all audited fields from the entity's table with two fields, 
REVTYPE (values are: “0” for adding, “1” for updating, “2” for removing an entity) and REV.

Besides these, an extra table named REVINFO will be generated by default, it includes two important fields, 
REV and REVTSTMP and records the timestamp of every revision. And as you can guess, bar_AUD.REV and foo_AUD.REV are actually foreign keys to REVINFO.REV.
________________________________________________________________________________________________________________________________
***** @AuditTable you can specify the table name for auditing an entity 